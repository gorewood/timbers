+++
title = 'Decision Log'
date = '2026-02-28'
tags = ['example', 'decision-log']
+++

Generated with `timbers draft decision-log --last 20 | claude -p --model opus`

---

## ADR-1: Static Examples Over Per-Release LLM Generation

**Context:** Site examples (changelog, standup, etc.) were regenerated by LLM on every release. Some examples drew from dense date ranges that don't change between releases, meaning the LLM was invoked redundantly to produce identical output.

**Decision:** Split example generation into static (fixed date ranges, generated once) and dynamic (per-release). Static examples from dense periods like Feb 10-14 are committed and reused; only release-dependent examples invoke the LLM.

**Consequences:**
- Faster, cheaper releases — no LLM calls for content that hasn't changed
- Static examples are deterministic and reviewable in git history
- Adds a two-track build system that contributors need to understand
- If the static date ranges become stale or irrelevant, someone must decide when to refresh them

---

## ADR-2: Clean Template Rename Over Backward-Compatible Alias

**Context:** The `exec-summary` template was being renamed to `standup` for better discoverability. The question was whether to keep `exec-summary` as a backward-compatible alias.

**Decision:** Clean break — rename to `standup` with no alias. Pre-GA project with low usage means backward compatibility adds complexity for no real benefit.

**Consequences:**
- Simpler codebase — no alias resolution logic or deprecation warnings
- Better discoverability: `timbers draft standup` is self-explanatory
- Anyone with scripts using `exec-summary` breaks silently — acceptable only because the project is pre-GA
- Sets a precedent that pre-GA naming can change freely, which must stop at GA

---

## ADR-3: Intent-Focused PR Template Over Diff-Centric Output

**Context:** The PR description template (v3) was structured around code diffs — what files changed, what lines were modified. Agents already review diffs natively, making this redundant.

**Decision:** Rewrote the PR template (v4) to focus on intent and decisions — what was the goal, what alternatives were considered, what trade-offs were made. Agents handle diff review; humans need the "why."

**Consequences:**
- PR descriptions add value that tooling doesn't already provide
- Reviewers get decision context upfront instead of re-deriving it from diffs
- Template is now more dependent on rich `why`/`notes` fields in ledger entries — thin entries produce thin PRs
- Agents that don't capture good decision context will produce weaker PR descriptions

---

## ADR-4: Check-Before-Generate Over Teaching the LLM to Refuse

**Context:** The devblog CI workflow invoked the LLM even when no ledger entries existed for the period. The LLM would generate apologetic "no updates this week" posts — correct behavior from the model's perspective, but unwanted output.

**Decision:** Add an entry count check before invoking the LLM. Skip generation entirely when count is zero. Cheaper and cleaner than prompt-engineering the LLM to output nothing.

**Consequences:**
- Zero LLM cost for empty periods — check is a simple count
- No risk of the LLM inventing content to fill the gap
- Requires the count check to stay in sync with how entries are queried — a mismatch could skip real content
- Pattern generalizes: validate inputs before calling expensive external services rather than handling edge cases inside the service

---

## ADR-5: Actionable Warnings Over Explicit Anchor-Reset Command

**Context:** After squash merges, the timbers anchor commit disappears from history, causing confusing `pending` output. Options: (a) build an `anchor reset` command, or (b) show actionable warnings and let the anchor self-heal on next `timbers log`.

**Decision:** Warnings plus coaching, no reset command. The anchor self-heals naturally when the next entry is recorded, making an explicit reset unnecessary. Added coaching section to prime workflow explaining the behavior.

**Consequences:**
- No new command to maintain, document, or test
- Users understand what happened and why — messaging alone is sufficient
- Brief window of confusing `pending` output until the next `timbers log` call
- If self-healing breaks in a future edge case, there's no manual escape hatch — would need to add the command then

---

## ADR-6: Stop Hook Over PostToolUse for Pending Reminders

**Context:** A PostToolUse hook was designed to remind agents about `timbers pending` after `git commit`. Diagnostic confirmed the hook fired correctly and received the right JSON on stdin. However, Claude Code doesn't surface hook stdout to the agent — the output went nowhere visible.

**Decision:** Remove PostToolUse entirely. The existing Stop hook already runs `timbers pending` at session end, which does display output. One reliable check at session end beats an invisible per-commit check.

**Consequences:**
- One fewer hook to maintain and debug
- Pending check happens at session end rather than per-commit — agents may accumulate undocumented commits during a session
- Eliminates dependency on Claude Code's PostToolUse stdout behavior, which could change
- Added retired-event cleanup logic so upgrades remove stale hooks — useful pattern for future hook deprecations

---

## ADR-7: Auto-Commit Entry Files with Pathspec Scoping

**Context:** `timbers log` wrote entry files to `.timbers/` but didn't commit them, leaving a staged-but-uncommitted gap that confused users. The original design likely assumed git-notes storage where entries don't create working-tree commits. Options: (a) auto-commit on the working branch with pathspec, (b) commit to a separate branch (like beads/entire.io), (c) leave it manual.

**Decision:** Auto-commit with `git commit -m ... -- <path>` scoped to the entry file only. Separate branch was rejected because agent DX depends on filesystem visibility — `timbers prime` and `timbers draft` need to read entries without worktree indirection.

**Consequences:**
- Eliminates the manual `git add && git commit` step for entry files
- Pathspec (`--`) prevents sweeping other staged files into the timbers commit — critical safety property
- Entry commits appear on the working branch, interleaved with code commits
- `GitCommitFunc` injection makes the commit behavior testable and mockable
- Filesystem-visible entries lock in the `.timbers/` directory approach — migrating to git-notes or a separate branch later would require rethinking `prime`/`draft` reads

---

## ADR-8: `--color` Flag Over Full Theme Configuration

**Context:** User reported Color 8 (bright black) was invisible on Solarized Dark terminals. Terminals don't reliably report their color scheme, so auto-detection isn't trustworthy. Options: (a) `--color` flag with `never/auto/always`, (b) full theme config via env vars and config files, (c) lipgloss `AdaptiveColor` alone.

**Decision:** `--color` persistent flag (`never/auto/always`) combined with `AdaptiveColor` for light/dark switching. Full theme configuration deferred — the flag covers 95% of cases without maintenance burden. Lipgloss v1.1.0's `HasDarkBackground()` noted for future use.

**Consequences:**
- Immediate fix for dark-terminal users without overengineering
- `--color=never` is a universal escape hatch for any color rendering issue
- Persistent flag means it's set once, not per-command
- Defers full theming, which means no custom color palettes or per-element styling
- `ResolveColorMode` must be plumbed to every `NewPrinter` call site — added coupling across commands

---

## ADR-9: Grep Stdin Over jq Parsing for Hook Input Detection

**Context:** The PostToolUse hook needed to detect `git commit` in the JSON payload received on stdin (not via `$TOOL_INPUT` env var, which was always empty — the original bug). Options: (a) `jq`-based JSON parsing to extract `tool_input.command` specifically, (b) grep the full JSON blob for the string.

**Decision:** Grep the raw JSON stream. Simpler, needs no external dependencies (`jq` isn't guaranteed), and false-positive risk for "git commit" appearing in non-command JSON fields is negligible.

**Consequences:**
- Zero external dependencies — works on any system with grep
- Marginally less precise than structured JSON parsing — could theoretically match "git commit" in a string field
- Upgrade logic uses `hasExactHookCommand` to detect stale vs current hooks, enabling clean replacement instead of the old skip-if-any-exists behavior that left broken hooks in place
- Pattern established: for simple string detection in hook payloads, grep beats structured parsing

---

## ADR-10: Preemptive Coaching Over Runtime Content Filtering

**Context:** Ledger entries are committed to git and may be visible in public repositories. Agents could inadvertently include API keys, personal names, or internal URLs in entry fields.

**Decision:** Add a content-safety coaching section to `timbers prime` output — a preemptive guardrail that instructs agents what not to include, rather than runtime filtering or redaction of entry content.

**Consequences:**
- Zero runtime overhead — no scanning or regex matching on entry writes
- Works across all LLM providers since it's prompt-level guidance, not code
- Entirely dependent on the agent following instructions — no enforcement if the agent ignores coaching
- No false positives from overzealous regex filters blocking legitimate technical content
- If coaching proves insufficient, runtime filtering can be added as a second layer without removing the coaching
